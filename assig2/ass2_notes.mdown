# Assignment 2
## Part 1:
### Shared memory pi-calculation
#### 1. Serial implementation
Code that integrates function 1/(1+x^2) over [0, 1].
```C++
//function to be integrated
double phi(double x) {
    return 1 / (1 + x*x);
}

int main(int argc, char** argv)
{
    int i;
    double h, y, sum;
    //number of partitions
    long n = 100000000;

    h = 1. / n;

    sum = 0;

    for (i = 0; i <= n; i++)
    {
        //calculate function value at current partition
        y = phi(i*h);
        //add current function value to sum
        sum += y;
    }
    sum *= 4. * h;
	//result of integration is in sum
	
    return 0;
}
```

#### 2. Parralelized application
With the critical directive, the for loop becomes:
```C++
#pragma omp parallel for private(y), shared(sum) 
    for (i = 0; i <= n; i++)
    {
        //calculate function value at current partition
        y = phi(i*h);
#pragma omp critical 
        //add current function value to sum
        sum += y;
    }
```
Using the reduction clause, the for loop looks like the following:
```C++
#pragma omp parallel for private(y), reduction(+: sum)
    for (i = 0; i <= n; i++)
    {
        //calculate function value at current partition
        y = phi(i*h);
        //add current function value to sum
        sum += y;
    }
```

#### 3. Scaling study
The time values are in microseconds.

##### Weak scaling using the critical directive
n = 1 000 000.

N/Nr of threads: n/16.
Time of execution (millis): 752.

N/Nr of threads: 2n/32.
Time of execution (millis): 1452.

N/Nr of threads: 4n/64.
Time of execution (millis): 2917.

N/Nr of threads: 8n/128.
Time of execution (millis): 5920.

N/Nr of threads: 16n/256.
Time of execution (millis): 19458.

##### Strong scaling using the critical directive
n = 10 000 000.

Nr of threads: 16.
Time of execution (millis): 7304.

Nr of threads: 32.
Time of execution (millis): 7390.

Nr of threads: 64.
Time of execution (millis): 7374.

Nr of threads: 128.
Time of execution (millis): 7780.

Nr of threads: 256.
Time of execution (millis): 13523.

Because every single thread has to access the critical zone sequentially, the time of execution slows down by using the critical directive.


##### Weak scaling using the reduction clause
n = 1 000 000.

N/Nr of threads: n/16.
Time of execution (millis): 31.

N/Nr of threads: 2n/32.
Time of execution (millis): 37.

N/Nr of threads: 4n/64.
Time of execution (millis): 50.

N/Nr of threads: 8n/128.
Time of execution (millis): 73.

N/Nr of threads: 16n/256.
Time of execution (millis): 209.

##### Strong scaling using the reduction clause
n = 10 000 000.

Nr of threads: 16.
Time of execution (millis): 35.

Nr of threads: 32.
Time of execution (millis): 36.

Nr of threads: 64.
Time of execution (millis): 47.

Nr of threads: 128.
Time of execution (millis): 69.

Nr of threads: 256.
Time of execution (millis): 113.

## Part 2